<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>正方體展開圖模擬器</title>
    <!-- Tailwind CSS for UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f2f5; font-family: "Noto Sans TC", sans-serif; }
        canvas { display: block; }
        
        /* 自定義滑桿樣式 */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -10px; 
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #cbd5e1;
            border-radius: 2px;
        }
        
        /* Logo 區域樣式 */
        .logo-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo-img {
            max-width: 100%;
            height: auto;
            display: block;
        }

        .logo-placeholder {
            width: 120px;
            height: 40px;
            border: 2px dashed #cbd5e1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #64748b;
            font-size: 12px;
            font-weight: bold;
        }

        /* 載入畫面 */
        #loader {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <!-- 載入指示器 -->
    <div id="loader">
        <div class="text-blue-500 text-xl font-bold animate-pulse">載入模擬器中...</div>
    </div>

    <!-- UI 介面 -->
    <div class="absolute top-5 left-5 z-10 pointer-events-none">
        <h1 class="text-2xl font-bold text-gray-800 drop-shadow-md">正方體展開圖模擬器</h1>
        <p class="text-sm text-gray-600 mt-1">拖曳旋轉視角 • 滾輪縮放</p>
    </div>

    <!-- 公司 Logo (預留位) -->
    <div class="logo-container">
        <!-- 這裡放 logo.png。onerror 會處理圖片不存在的情況，顯示預設框 -->
        <img src="logo.png" alt="Company Logo" class="logo-img" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
        <div class="logo-placeholder" style="display: none;">
            LOGO 預留位
        </div>
    </div>

    <!-- 控制面板 -->
    <div class="absolute bottom-8 left-1/2 transform -translate-x-1/2 w-11/12 max-w-lg bg-white/90 backdrop-blur-sm p-6 rounded-2xl shadow-xl z-10">
        <div class="flex flex-col gap-4">
            
            <div class="flex justify-between items-center">
                <label class="text-gray-700 font-bold">折疊進度</label>
                <span id="angle-display" class="text-blue-600 font-mono font-bold">0%</span>
            </div>

            <input type="range" id="fold-slider" min="0" max="100" value="0" step="0.1" class="w-full">

            <div class="flex gap-3 mt-1">
                <button id="btn-unfold" class="flex-1 py-2 px-4 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-lg font-medium transition" onclick="setFold(0)">
                    平攤 (展開)
                </button>
                <button id="btn-auto" class="flex-1 py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium shadow-lg transition flex justify-center items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0zM4.5 7.5a.5.5 0 0 0 0 1h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 1 0-.708.708L10.293 7.5H4.5z"/>
                    </svg>
                    自動演示
                </button>
                <button id="btn-fold" class="flex-1 py-2 px-4 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-lg font-medium transition" onclick="setFold(100)">
                    組裝 (折疊)
                </button>
            </div>
        </div>
    </div>

    <!-- 3D Canvas -->
    <script>
        // --- 變數與設定 ---
        let scene, camera, renderer, controls;
        let faces = []; // 儲存所有面
        let pivots = {}; // 儲存旋轉軸
        let isAutoPlaying = false;
        let autoPlayDirection = 1; // 1 為折疊, -1 為展開
        
        // 正方體參數
        const FACE_SIZE = 2;
        const FACE_THICKNESS = 0.05;
        const GAP = 0.02; // 面與面之間的微小間隙，避免重疊閃爍
        
        // 顏色設定 (使用骰子邏輯：對面顏色可互補，這裡維持繽紛色系)
        // 1(藍) 對 6(紅)
        // 2(粉) 對 3(紫)
        // 4(綠) 對 5(黃)
        const COLORS = {
            base: 0x3b82f6,    // 1: 藍 (底)
            right: 0xec4899,   // 2: 粉 (右)
            left: 0x8b5cf6,    // 3: 紫 (左)
            front: 0x10b981,   // 4: 綠 (前)
            back: 0xf59e0b,    // 5: 黃 (後)
            top: 0xef4444      // 6: 紅 (頂/蓋)
        };

        const BG_COLOR = 0xf0f2f5;

        // --- 初始化 ---
        function init() {
            // 1. 場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(BG_COLOR);
            scene.fog = new THREE.Fog(BG_COLOR, 10, 50);

            // 2. 相機
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(8, 8, 12);
            camera.lookAt(0, 0, 0);

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 4. 燈光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. 地板網格
            const gridHelper = new THREE.GridHelper(30, 30, 0xccd5ae, 0xe0e5ec);
            scene.add(gridHelper);

            // 6. 控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 1.5;

            // 7. 創建幾何體 (核心邏輯)
            createUnfoldedCube();

            // 8. 移除載入畫面
            const loader = document.getElementById('loader');
            if(loader) {
                setTimeout(() => {
                    loader.style.opacity = 0;
                    setTimeout(() => loader.remove(), 500);
                }, 500);
            }

            // 9. 事件監聽
            window.addEventListener('resize', onWindowResize);
            
            // 開始渲染迴圈
            animate();
        }

        // --- 創建正方體面 (包含數字貼圖) ---
        function createFaceMesh(color, number) {
            const geometry = new THREE.BoxGeometry(FACE_SIZE, FACE_THICKNESS, FACE_SIZE);
            
            // 內部函式：生成 Canvas 貼圖
            function getTexture(num, col) {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // 1. 填滿背景色
                ctx.fillStyle = '#' + new THREE.Color(col).getHexString();
                ctx.fillRect(0, 0, 512, 512);
                
                // 2. 畫內邊框 (增加質感)
                ctx.lineWidth = 15;
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.strokeRect(20, 20, 472, 472);

                // 3. 畫數字
                ctx.font = 'bold 250px "Noto Sans TC", sans-serif';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // 稍微調整 y 軸讓視覺置中
                ctx.fillText(num, 256, 276);
                
                const tex = new THREE.CanvasTexture(canvas);
                return tex;
            }

            // 建立貼圖與材質
            const texture = getTexture(number, color);
            const plainMaterial = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7, metalness: 0.1 });
            const textureMaterial = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.7, metalness: 0.1 });

            // BoxGeometry 的材質索引順序:
            // 0: x+ (右側邊)
            // 1: x- (左側邊)
            // 2: y+ (頂面 - 平攤時看到的那面)
            // 3: y- (底面 - 背面)
            // 4: z+ (前側邊)
            // 5: z- (後側邊)
            
            // 我們將有數字的材質貼在 y+ (主要面) 和 y- (背面)，這樣無論內外都看得到數字
            const materials = [
                plainMaterial, 
                plainMaterial, 
                textureMaterial, 
                textureMaterial, 
                plainMaterial, 
                plainMaterial
            ];

            const mesh = new THREE.Mesh(geometry, materials);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            // 添加邊框線條，讓立體感更明顯
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }));
            mesh.add(line);
            
            return mesh;
        }

        // --- 建立層次結構 (Hierarchy) ---
        function createUnfoldedCube() {
            const halfSize = FACE_SIZE / 2;

            // 1. 底面 (Base) -> 數字 1
            const baseMesh = createFaceMesh(COLORS.base, 1);
            baseMesh.position.y = FACE_THICKNESS / 2;
            scene.add(baseMesh);

            // 2. 右面 (Right) -> 數字 2
            pivots.right = new THREE.Group();
            pivots.right.position.set(halfSize + GAP, FACE_THICKNESS / 2, 0); 
            scene.add(pivots.right);

            const rightMesh = createFaceMesh(COLORS.right, 2);
            rightMesh.position.set(halfSize, 0, 0); 
            pivots.right.add(rightMesh);

            // 3. 左面 (Left) -> 數字 3
            pivots.left = new THREE.Group();
            pivots.left.position.set(-halfSize - GAP, FACE_THICKNESS / 2, 0);
            scene.add(pivots.left);

            const leftMesh = createFaceMesh(COLORS.left, 3);
            leftMesh.position.set(-halfSize, 0, 0);
            pivots.left.add(leftMesh);

            // 4. 前面 (Front) -> 數字 4
            pivots.front = new THREE.Group();
            pivots.front.position.set(0, FACE_THICKNESS / 2, halfSize + GAP);
            scene.add(pivots.front);

            const frontMesh = createFaceMesh(COLORS.front, 4);
            frontMesh.position.set(0, 0, halfSize);
            pivots.front.add(frontMesh);

            // 5. 後面 (Back) -> 數字 5
            pivots.back = new THREE.Group();
            pivots.back.position.set(0, FACE_THICKNESS / 2, -halfSize - GAP);
            scene.add(pivots.back);

            const backMesh = createFaceMesh(COLORS.back, 5);
            backMesh.position.set(0, 0, -halfSize);
            pivots.back.add(backMesh);

            // 6. 頂面 (Top) - 連接在後面 (Back) -> 數字 6
            pivots.top = new THREE.Group();
            pivots.top.position.set(0, 0, -FACE_SIZE - GAP); 
            pivots.back.add(pivots.top);

            const topMesh = createFaceMesh(COLORS.top, 6);
            topMesh.position.set(0, 0, -halfSize);
            pivots.top.add(topMesh);
        }

        // --- 動畫與更新邏輯 ---
        function updateFold(percentage) {
            // 0% = 0度, 100% = 90度 (Math.PI / 2)
            const angle = (percentage / 100) * (Math.PI / 2);

            // 右面：繞 Z 軸逆時針轉 (向上)
            pivots.right.rotation.z = angle;
            
            // 左面：繞 Z 軸順時針轉
            pivots.left.rotation.z = -angle;

            // 前面：繞 X 軸逆時針轉 (注意 Three.js 座標系)
            pivots.front.rotation.x = -angle;

            // 後面：繞 X 軸順時針轉
            pivots.back.rotation.x = angle;

            // 頂面：相對於後面，繼續轉 90 度
            pivots.top.rotation.x = angle;
        }

        // --- 滑桿與按鈕邏輯 ---
        const slider = document.getElementById('fold-slider');
        const angleDisplay = document.getElementById('angle-display');
        const btnAuto = document.getElementById('btn-auto');

        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            updateFold(val);
            angleDisplay.innerText = Math.round(val) + '%';
            
            // 手動介入時停止自動播放
            if(isAutoPlaying) toggleAutoPlay();
        });

        // 外部呼叫設定
        window.setFold = function(val) {
            slider.value = val;
            updateFold(val);
            angleDisplay.innerText = val + '%';
            if(isAutoPlaying) toggleAutoPlay();
        };

        // 自動播放邏輯
        btnAuto.addEventListener('click', toggleAutoPlay);

        function toggleAutoPlay() {
            isAutoPlaying = !isAutoPlaying;
            
            if(isAutoPlaying) {
                btnAuto.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                btnAuto.classList.add('bg-red-500', 'hover:bg-red-600');
                btnAuto.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" class="mr-2">
                        <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/>
                    </svg> 停止
                `;
                
                const currentVal = parseFloat(slider.value);
                if (currentVal >= 100) autoPlayDirection = -1;
                else if (currentVal <= 0) autoPlayDirection = 1;
            } else {
                btnAuto.classList.add('bg-blue-600', 'hover:bg-blue-700');
                btnAuto.classList.remove('bg-red-500', 'hover:bg-red-600');
                btnAuto.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" class="mr-2">
                        <path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0zM4.5 7.5a.5.5 0 0 0 0 1h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 1 0-.708.708L10.293 7.5H4.5z"/>
                    </svg> 自動演示
                `;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // 自動播放邏輯
            if (isAutoPlaying) {
                let currentVal = parseFloat(slider.value);
                const speed = 0.5;

                currentVal += speed * autoPlayDirection;

                if (currentVal >= 100) {
                    currentVal = 100;
                    autoPlayDirection = -1;
                } else if (currentVal <= 0) {
                    currentVal = 0;
                    autoPlayDirection = 1;
                }

                slider.value = currentVal;
                angleDisplay.innerText = Math.round(currentVal) + '%';
                updateFold(currentVal);
            }

            renderer.render(scene, camera);
        }

        // 啟動
        init();

    </script>
</body>
</html>
