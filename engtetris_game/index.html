<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Word Tetris: 詞綴方塊</title>
    
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 引入 React 和 ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 引入 Babel 用於解析 JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* 自定義樣式 */
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.2); border-radius: 4px; }
        @keyframes fade-out {
          0% { opacity: 1; transform: scale(0.9); }
          10% { opacity: 1; transform: scale(1.1); }
          100% { opacity: 0; transform: scale(1); }
        }
        .animate-fade-out { animation: fade-out 1.5s forwards ease-out; }
        
        @keyframes spin-slow {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        .animate-spin-slow { animation: spin-slow 3s linear infinite; }

        /* 防止手機端雙擊縮放和長按選取 */
        body {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            /* 確保在 iOS 上也能滿版 */
            height: 100vh;
            height: 100dvh;
        }
        
        /* 按鈕按下效果 */
        .btn-active:active {
            transform: scale(0.95);
            background-color: rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="bg-slate-900 text-white font-sans overflow-hidden">
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- 圖標組件 (Inline SVG) ---
        const IconWrapper = ({ children, size = 24, className = "" }) => (
          <svg 
            xmlns="http://www.w3.org/2000/svg" 
            width={size} 
            height={size} 
            viewBox="0 0 24 24" 
            fill="none" 
            stroke="currentColor" 
            strokeWidth="2" 
            strokeLinecap="round" 
            strokeLinejoin="round" 
            className={className}
          >
            {children}
          </svg>
        );

        const Play = (props) => <IconWrapper {...props}><polygon points="5 3 19 12 5 21 5 3" /></IconWrapper>;
        const RotateCcw = (props) => <IconWrapper {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5" /></IconWrapper>;
        const ArrowLeft = (props) => <IconWrapper {...props}><line x1="19" y1="12" x2="5" y2="12" /><polyline points="12 19 5 12 12 5" /></IconWrapper>;
        const ArrowRight = (props) => <IconWrapper {...props}><line x1="5" y1="12" x2="19" y2="12" /><polyline points="12 5 19 12 12 19" /></IconWrapper>;
        const ArrowDown = (props) => <IconWrapper {...props}><line x1="12" y1="5" x2="12" y2="19" /><polyline points="19 12 12 19 5 12" /></IconWrapper>;
        const Type = (props) => <IconWrapper {...props}><polyline points="4 7 4 4 20 4 20 7" /><line x1="9" y1="20" x2="15" y2="20" /><line x1="12" y1="4" x2="12" y2="20" /></IconWrapper>;
        const Sparkles = (props) => <IconWrapper {...props}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z" /><path d="M5 3v4" /><path d="M9 5h4" /><path d="M19 17v4" /><path d="M15 19h4" /></IconWrapper>;
        const Lock = (props) => <IconWrapper {...props}><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></IconWrapper>;
        const BookOpen = (props) => <IconWrapper {...props}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z" /><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z" /></IconWrapper>;
        const Target = (props) => <IconWrapper {...props}><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></IconWrapper>;
        const X = (props) => <IconWrapper {...props}><line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" /></IconWrapper>;
        const ChevronRight = (props) => <IconWrapper {...props}><polyline points="9 18 15 12 9 6" /></IconWrapper>;
        const Volume2 = (props) => <IconWrapper {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" /><path d="M19.07 4.93a10 10 0 0 1 0 14.14" /><path d="M15.54 8.46a5 5 0 0 1 0 7.07" /></IconWrapper>;
        const VolumeX = (props) => <IconWrapper {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" /><line x1="23" y1="9" x2="17" y2="15" /><line x1="17" y1="9" x2="23" y2="15" /></IconWrapper>;
        const Clock = (props) => <IconWrapper {...props}><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></IconWrapper>;
        const Trophy = (props) => <IconWrapper {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" /><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" /><path d="M4 22h16" /><path d="M10 14.66V17" /><path d="M14 14.66V17" /><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z" /></IconWrapper>;
        const PauseIcon = (props) => <IconWrapper {...props}><rect x="6" y="4" width="4" height="16" /><rect x="14" y="4" width="4" height="16" /></IconWrapper>;

        // --- 遊戲資料庫 ---
        const WORD_PAIRS_DATA = [
          ['help', 'er', 'helper', 1, '助手', 'A person who helps'],
          ['play', 'er', 'player', 1, '玩家', 'A person taking part in a game'],
          ['teach', 'er', 'teacher', 1, '教師', 'A person who teaches'],
          ['un', 'happy', 'unhappy', 1, '不快樂的', 'Not happy'],
          ['help', 'less', 'helpless', 2, '無助的', 'Unable to help oneself'],
          ['kind', 'ness', 'kindness', 2, '仁慈', 'The quality of being friendly'],
          ['dis', 'like', 'dislike', 3, '不喜歡', 'Feel distaste for'],
          ['mis', 'take', 'mistake', 3, '錯誤', 'An action or judgment that is wrong'],
          ['pre', 'view', 'preview', 4, '預覽', 'An inspection before it is available'],
          ['re', 'view', 'review', 4, '複習', 'A formal assessment'],
          ['im', 'possible', 'impossible', 5, '不可能的', 'Not able to occur'],
          ['in', 'active', 'inactive', 5, '不活躍的', 'Not engaging in physical activity'],
          ['slow', 'ly', 'slowly', 6, '緩慢地', 'At a slow speed'],
          ['quick', 'ly', 'quickly', 6, '快速地', 'At a fast speed'],
          ['home', 'work', 'homework', 7, '家庭作業', 'Schoolwork done at home'],
          ['foot', 'ball', 'football', 7, '足球', 'A game played with a ball'],
          ['sun', 'flower', 'sunflower', 8, '向日葵', 'A tall plant with yellow flowers'],
          ['friend', 'ship', 'friendship', 8, '友誼', 'The emotions or conduct of friends'],
          ['inter', 'view', 'interview', 9, '面試', 'A meeting of people face to face'],
          ['super', 'man', 'superman', 9, '超人', 'A man with superhuman powers'],
          ['use', 'ful', 'useful', 10, '有用的', 'Able to be used for a practical purpose'],
          ['use', 'less', 'useless', 10, '無用的', 'Not fulfilling an intended purpose'],
          ['move', 'ment', 'movement', 6, '移動', 'An act of changing physical location'],
          ['state', 'ment', 'statement', 6, '聲明', 'A definite or clear expression'],
          ['enjoy', 'able', 'enjoyable', 6, '愉快的', 'Giving delight or pleasure'],
          ['break', 'able', 'breakable', 6, '易碎的', 'Capable of being broken'],
          ['care', 'ful', 'careful', 7, '小心的', 'Making sure of avoiding potential danger'],
          ['hope', 'ful', 'hopeful', 7, '充滿希望的', 'Feeling or inspiring optimism'],
          ['color', 'less', 'colorless', 7, '無色的', 'Without color'],
          ['home', 'less', 'homeless', 7, '無家可歸的', 'Without a home'],
          ['mid', 'night', 'midnight', 8, '午夜', 'Twelve o\'clock at night'],
          ['mid', 'day', 'midday', 8, '正午', 'The middle of the day'],
          ['over', 'cook', 'overcook', 8, '煮過頭', 'Cook too much'],
          ['over', 'heat', 'overheat', 8, '過熱', 'Make or become too hot'],
          ['inter', 'net', 'internet', 9, '網際網路', 'A global computer network'],
          ['ex', 'port', 'export', 9, '出口', 'Send goods to another country'],
          ['im', 'port', 'import', 9, '進口', 'Bring goods into a country'],
          ['trans', 'form', 'transform', 10, '改變', 'Make a thorough or dramatic change'],
          ['trans', 'port', 'transport', 10, '運輸', 'Take or carry from one place to another'],
          ['sub', 'way', 'subway', 10, '地鐵', 'An underground electric railroad'],
          ['sub', 'marine', 'submarine', 10, '潛水艇', 'A warship with a streamlined hull designed to operate completely submerged']
        ];

        const GRID_W = 10;
        const GRID_H = 14; 

        const COLORS = {
          prefix: 'bg-blue-600 border-blue-400 text-white shadow-md', 
          root: 'bg-emerald-600 border-emerald-400 text-white shadow-md',   
          suffix: 'bg-orange-500 border-orange-400 text-white shadow-md', 
          ghost: 'bg-slate-800 border-2 border-slate-700 border-dashed text-slate-600', 
          word_locked: 'bg-slate-700 border-slate-600 text-slate-400' 
        };

        const getPartType = (text) => {
          const prefixes = ['un', 're', 'dis', 'mis', 'pre', 'im', 'in', 'non', 'over', 'super', 'auto', 'bio', 'mid', 'inter', 'ex', 'trans', 'sub'];
          const suffixes = ['less', 'ful', 'ness', 'ly', 'ion', 'er', 'ist', 'ship', 'ment', 'able'];
          if (prefixes.includes(text)) return 'prefix'; 
          if (suffixes.includes(text)) return 'suffix'; 
          return 'root'; 
        };

        const getPartColor = (text) => {
          const type = getPartType(text);
          if (type === 'prefix') return COLORS.prefix;
          if (type === 'suffix') return COLORS.suffix;
          return COLORS.root; 
        };

        // BGM URL (Tetris Theme - Korobeiniki)
        const BGM_URL = "https://ia800504.us.archive.org/33/items/TetrisThemeMusic/Tetris.mp3";

        function WordTetris() {
          const [grid, setGrid] = useState(Array(GRID_H).fill(null).map(() => Array(GRID_W).fill(null)));
          const [activePiece, setActivePiece] = useState(null); 
          const [score, setScore] = useState(0);
          const [gameState, setGameState] = useState('HOME'); 
          
          const [showCollection, setShowCollection] = useState(false);
          const [clearedWords, setClearedWords] = useState([]); 
          const [combo, setCombo] = useState(0);
          
          const [discoveredWords, setDiscoveredWords] = useState(new Set());
          const [definitionModal, setDefinitionModal] = useState(null);
          const [topMessage, setTopMessage] = useState(null); 
          
          // 計時器狀態
          const [timeLeft, setTimeLeft] = useState(60);
          const [lastAddedTime, setLastAddedTime] = useState(0);
          
          // 關卡狀態
          const [level, setLevel] = useState(1);
          const [nextLevelScore, setNextLevelScore] = useState(300); // Level 1 target

          const [isMuted, setIsMuted] = useState(false);
          const audioRef = useRef(null);

          const gameLoopRef = useRef();
          const speedRef = useRef(900); 
          const touchStartRef = useRef(null);
          const lastMoveTimeRef = useRef(0);

          // "Bag" 機制
          const bagsRef = useRef({ prefix: [], root: [], suffix: [] });
          const bagRef = useRef([]); // Pair-based bag
          
          const pendingLevelUpRef = useRef(false);

          // 無盡模式狀態
          const [shuffledPairs, setShuffledPairs] = useState([]); 
          const [unlockedCount, setUnlockedCount] = useState(1); 

          // 初始化音訊
          const initAudio = () => {
             if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance('');
                window.speechSynthesis.speak(utterance);
             }
             if (audioRef.current) {
                 audioRef.current.play().then(() => {
                     audioRef.current.pause();
                 }).catch(e => console.log("Audio unlock interaction"));
             }
          };

          const speakWord = (word) => {
            if ('speechSynthesis' in window) {
              const utterance = new SpeechSynthesisUtterance(word);
              utterance.lang = 'en-US';
              utterance.rate = 0.9;
              window.speechSynthesis.speak(utterance);
            }
          };

          useEffect(() => {
            if (audioRef.current) {
              audioRef.current.volume = 0.3; 
              if (gameState === 'PLAYING' && !isMuted) {
                const playPromise = audioRef.current.play();
                if (playPromise !== undefined) {
                  playPromise.catch(error => console.log("Audio play blocked"));
                }
              } else {
                audioRef.current.pause();
              }
            }
          }, [gameState, isMuted]);

          const getAvailableParts = useCallback(() => {
            if (shuffledPairs.length === 0) return [];
            const activePairs = shuffledPairs.slice(0, unlockedCount);
            return Array.from(new Set(activePairs.flatMap(p => [p[0], p[1]])));
          }, [shuffledPairs, unlockedCount]);

          // Bag 補貨函式
          const refillBag = useCallback(() => {
            if (shuffledPairs.length === 0) return [];
            
            const activePairs = shuffledPairs.slice(0, unlockedCount);
            let newBag = [];
            
            activePairs.forEach(pair => {
                newBag.push(pair[0]); 
                newBag.push(pair[1]); 
            });

            for (let i = newBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newBag[i], newBag[j]] = [newBag[j], newBag[i]];
            }
            return newBag;
          }, [shuffledPairs, unlockedCount]);

          const spawnPiece = useCallback(() => {
            if (shuffledPairs.length === 0) return;

            let bag = bagRef.current;
            if (bag.length === 0) {
                bag = refillBag();
                bagRef.current = bag;
            }

            const selectedPart = bag.pop(); 
            if (!selectedPart) return; 

            const partColor = getPartColor(selectedPart);

            const W = { type: 'word', text: selectedPart, color: partColor };
            const G = { type: 'ghost', text: '', color: COLORS.ghost }; 

            let hasRight = false;
            let hasDown = false;
            let hasLeft = false;
            let hasUp = false;

            const activePairs = shuffledPairs.slice(0, unlockedCount);

            activePairs.forEach(pair => {
              if (pair[0] === selectedPart) {
                hasRight = true;
                hasDown = true;
              }
              if (pair[1] === selectedPart) {
                hasLeft = true;
                hasUp = true;
              }
            });
            
            if (!hasRight && !hasDown && !hasLeft && !hasUp) hasRight = true;

            const potentialShapes = [];
            if (hasRight) potentialShapes.push([{ x: 0, y: 0, cell: W }, { x: 1, y: 0, cell: G }]);
            if (hasDown)  potentialShapes.push([{ x: 0, y: 0, cell: W }, { x: 0, y: 1, cell: G }]);
            if (hasLeft)  potentialShapes.push([{ x: 0, y: 0, cell: W }, { x: -1, y: 0, cell: G }]);
            if (hasUp)    potentialShapes.push([{ x: 0, y: 0, cell: W }, { x: 0, y: -1, cell: G }]);
            
            const blocks = potentialShapes[Math.floor(Math.random() * potentialShapes.length)];

            const minX = Math.min(...blocks.map(b => b.x));
            const maxX = Math.max(...blocks.map(b => b.x));
            const minY = Math.min(...blocks.map(b => b.y));
            const maxY = Math.max(...blocks.map(b => b.y));

            const width = maxX - minX + 1;
            const height = maxY - minY + 1;

            const shape = Array(height).fill(null).map(() => Array(width).fill(null));

            blocks.forEach(b => {
              const cellWithId = { ...b.cell, id: Date.now() + Math.random() };
              shape[b.y - minY][b.x - minX] = cellWithId;
            });

            const newPiece = {
              x: Math.floor((GRID_W - shape[0].length) / 2),
              y: 0,
              shape: shape
            };

            if (checkCollision(newPiece.x, newPiece.y, newPiece.shape, grid, true)) {
              setGameState('GAMEOVER');
            } else {
              setActivePiece(newPiece);
              setGameState('PLAYING');
            }
          }, [grid, shuffledPairs, unlockedCount, refillBag]);

          // 修改：碰撞檢測邏輯 (虛擬塊不應被牆壁擋著)
          const checkCollision = (pieceX, pieceY, shape, currentGrid, isSpawnCheck = false) => {
            for (let y = 0; y < shape.length; y++) {
              for (let x = 0; x < shape[y].length; x++) {
                if (shape[y][x]) {
                  const targetX = pieceX + x;
                  const targetY = pieceY + y;
                  const pieceCellType = shape[y][x].type;

                  // 1. 邊界檢查
                  if (targetX < 0 || targetX >= GRID_W || targetY >= GRID_H) {
                    if (pieceCellType === 'word') return true;
                    if (pieceCellType === 'ghost') continue;
                  }

                  // 2. 網格佔用檢查
                  if (targetY >= 0 && targetX >= 0 && targetX < GRID_W) {
                    const gridCell = currentGrid[targetY][targetX];
                    if (gridCell === null) continue;
                    if (pieceCellType === 'ghost') continue; 
                    if (pieceCellType === 'word') {
                      if (gridCell.type === 'ghost') continue;
                      if (gridCell.type === 'word') return true;
                    }
                  }
                }
              }
            }
            return false;
          };

          const lockPiece = async () => {
            if (!activePiece) return;
            const newGrid = grid.map(row => [...row]);
            
            activePiece.shape.forEach((row, dy) => {
              row.forEach((cell, dx) => {
                if (cell) {
                  const targetY = activePiece.y + dy;
                  const targetX = activePiece.x + dx;
                  
                  if (targetY >= 0 && targetY < GRID_H && targetX >= 0 && targetX < GRID_W) {
                    const gridCell = newGrid[targetY][targetX];
                    if (cell.type === 'word') {
                       newGrid[targetY][targetX] = cell; 
                    } else if (cell.type === 'ghost') {
                       if (!gridCell || gridCell.type === 'ghost') {
                         newGrid[targetY][targetX] = cell;
                       }
                    }
                  }
                }
              });
            });

            const settledGrid = applyGravityImmediate(newGrid);
            setGrid(settledGrid);
            setActivePiece(null);

            const matches = findMatches(settledGrid);
            if (matches.length > 0) {
              setGameState('ANIMATING');
              await handleMatches(settledGrid, matches);
            } else {
              setCombo(0); 
              spawnPiece();
            }
          };

          const applyGravityImmediate = (currentGrid) => {
            const newGrid = Array(GRID_H).fill(null).map(() => Array(GRID_W).fill(null));
            for (let x = 0; x < GRID_W; x++) {
              const words = [];
              const ghosts = [];
              for (let y = GRID_H - 1; y >= 0; y--) {
                const cell = currentGrid[y][x];
                if (cell) {
                  if (cell.type === 'word') words.push(cell);
                  else if (cell.type === 'ghost') ghosts.push(cell);
                }
              }
              let writeY = GRID_H - 1;
              for (const w of words) {
                newGrid[writeY][x] = w;
                writeY--;
              }
              for (const g of ghosts) {
                if (writeY >= 0) {
                  newGrid[writeY][x] = g;
                  writeY--;
                }
              }
            }
            return newGrid;
          };

          const findMatches = (currentGrid) => {
            const matches = [];
            const usedIds = new Set(); 
            for (let y = 0; y < GRID_H; y++) {
              for (let x = 0; x < GRID_W; x++) {
                const cell = currentGrid[y][x];
                if (!cell || cell.type !== 'word') continue;

                if (x + 1 < GRID_W) {
                  const rightCell = currentGrid[y][x + 1];
                  if (rightCell && rightCell.type === 'word') {
                    const wordInfo = checkWordPair(cell.text, rightCell.text);
                    if (wordInfo && !usedIds.has(cell.id) && !usedIds.has(rightCell.id)) {
                      matches.push({ cells: [{x, y}, {x: x+1, y}], wordInfo });
                      usedIds.add(cell.id); usedIds.add(rightCell.id);
                    }
                  }
                }
                if (y + 1 < GRID_H) {
                  const downCell = currentGrid[y + 1][x];
                  if (downCell && downCell.type === 'word') {
                    const wordInfo = checkWordPair(cell.text, downCell.text);
                    if (wordInfo && !usedIds.has(cell.id) && !usedIds.has(downCell.id)) {
                      matches.push({ cells: [{x, y}, {x, y: y+1}], wordInfo });
                      usedIds.add(cell.id); usedIds.add(downCell.id);
                    }
                  }
                }
              }
            }
            return matches;
          };

          const checkWordPair = (part1, part2) => {
            const combined = part1 + part2;
            const found = WORD_PAIRS_DATA.find(p => p[2] === combined);
            if (found) {
              return { full: found[2], meaning_zh: found[4], meaning_en: found[5] };
            }
            return null;
          };

          const handleMatches = async (currentGrid, matches) => {
            let points = 0;
            const newClearedWords = [];
            let newDiscovery = null;

            const cellsToClear = new Set();
            const newlyFoundWords = []; 

            matches.forEach(m => {
              let isDiscovery = !discoveredWords.has(m.wordInfo.full) && !newlyFoundWords.includes(m.wordInfo.full);
              
              let matchScore = 0;
              let baseScore = 100 * (combo + 1);

              if (isDiscovery) {
                matchScore = baseScore + 200;
                newDiscovery = m.wordInfo;
                newlyFoundWords.push(m.wordInfo.full);
              } else {
                matchScore = baseScore;
              }
              
              points += matchScore;
              newClearedWords.push(m.wordInfo.full);

              m.cells.forEach(pos => {
                cellsToClear.add(`${pos.x},${pos.y}`);
                const neighbors = [{x: pos.x + 1, y: pos.y}, {x: pos.x - 1, y: pos.y}, {x: pos.x, y: pos.y + 1}, {x: pos.x, y: pos.y - 1}];
                neighbors.forEach(n => {
                  if (n.x >= 0 && n.x < GRID_W && n.y >= 0 && n.y < GRID_H) {
                    const cell = currentGrid[n.y][n.x];
                    if (cell && cell.type === 'ghost') {
                      cellsToClear.add(`${n.x},${n.y}`);
                    }
                  }
                });
              });
            });
            
            if (newlyFoundWords.length > 0) {
              setDiscoveredWords(prev => {
                const next = new Set(prev);
                newlyFoundWords.forEach(w => next.add(w));
                return next;
              });
            }
            
            if (newDiscovery) {
              setGameState('PAUSED');
              setDefinitionModal(newDiscovery);
              speakWord(newDiscovery.full);
              if (levelUpTriggered) pendingLevelUpRef.current = true; 
            } else if (levelUpTriggered) {
              setGameState('LEVEL_UP'); 
              setTimeLeft(prev => prev + 30);
              setLastAddedTime(30);
            } else {
              setTimeout(() => applyGravity(nextGrid), 300);
            }
            
            let currentScore = score + points;
            let levelUpTriggered = false;
            
            if (currentScore >= nextLevelScore) {
              levelUpTriggered = true;
              
              const nextLvl = level + 1;
              setLevel(nextLvl);
              setNextLevelScore(currentScore + 300 + (nextLvl * 50));
              
              if (unlockedCount < shuffledPairs.length) {
                const newWordPair = shuffledPairs[unlockedCount];
                setUnlockedCount(prev => prev + 1);
                setTopMessage(`LEVEL UP! 新增: ${newWordPair[2]}`);
              } else {
                setTopMessage(`LEVEL UP!`);
              }
              
              speedRef.current = Math.max(100, 900 - (nextLvl * 50));
            } else {
              setTimeLeft(prev => prev + 10);
              setLastAddedTime(10);
            }

            setScore(currentScore);
            setClearedWords(newClearedWords);
            setCombo(prev => prev + 1);
            
            const nextGrid = currentGrid.map(row => [...row]);
            cellsToClear.forEach(key => {
              const [cx, cy] = key.split(',').map(Number);
              nextGrid[cy][cx] = null;
            });

            setGrid(nextGrid);
            
            if (newDiscovery) {
              setGameState('PAUSED'); 
              setDefinitionModal(newDiscovery);
              speakWord(newDiscovery.full);
              if (levelUpTriggered) pendingLevelUpRef.current = true; 
            } else if (levelUpTriggered) {
              setGameState('LEVEL_UP'); 
              setTimeLeft(prev => prev + 30);
              setLastAddedTime(30);
            } else {
              setTimeout(() => applyGravity(nextGrid), 300);
            }
          };
          
          const continueLevel = () => {
             setGameState('PLAYING');
             applyGravity(grid);
          };

          const applyGravity = (currentGrid) => {
            const newGrid = applyGravityImmediate(currentGrid);
            setGrid(newGrid);
            
            setTimeout(() => {
              const newMatches = findMatches(newGrid);
              if (newMatches.length > 0) {
                setGameState('ANIMATING');
                handleMatches(newGrid, newMatches);
              } else {
                setClearedWords([]);
                spawnPiece();
              }
            }, 400);
          };

          const move = useCallback((dx, dy) => {
            const now = Date.now();
            if (now - lastMoveTimeRef.current < 100) return;
            lastMoveTimeRef.current = now;

            if (gameState !== 'PLAYING' || !activePiece) return;
            const nextX = activePiece.x + dx;
            const nextY = activePiece.y + dy;
            if (!checkCollision(nextX, nextY, activePiece.shape, grid)) {
              setActivePiece({ ...activePiece, x: nextX, y: nextY });
            } else if (dy > 0) {
              lockPiece();
            }
          }, [gameState, activePiece, grid]);

          const autoMove = useCallback((dx, dy) => {
             if (gameState !== 'PLAYING' || !activePiece) return;
             const nextX = activePiece.x + dx;
             const nextY = activePiece.y + dy;
             if (!checkCollision(nextX, nextY, activePiece.shape, grid)) {
               setActivePiece({ ...activePiece, x: nextX, y: nextY });
             } else if (dy > 0) {
               lockPiece();
             }
          }, [gameState, activePiece, grid]);

          const drop = () => {
            if (gameState !== 'PLAYING' || !activePiece) return;
            let tempY = activePiece.y;
            while (!checkCollision(activePiece.x, tempY + 1, activePiece.shape, grid)) {
              tempY++;
            }
            setActivePiece({ ...activePiece, y: tempY });
          };

          useEffect(() => {
            if (gameState !== 'PLAYING') return;
            gameLoopRef.current = setInterval(() => autoMove(0, 1), speedRef.current);
            return () => clearInterval(gameLoopRef.current);
          }, [gameState, autoMove]); 

          useEffect(() => {
            if (gameState !== 'PLAYING') return;
            const timerInterval = setInterval(() => {
              setTimeLeft(prevTime => {
                if (prevTime <= 1) {
                  setGameState('GAMEOVER');
                  return 0;
                }
                return prevTime - 1;
              });
            }, 1000);
            return () => clearInterval(timerInterval);
          }, [gameState]);

          useEffect(() => {
            const handleKeyDown = (e) => {
              if (gameState !== 'PLAYING') return;
              if (e.key === 'ArrowLeft') move(-1, 0);
              if (e.key === 'ArrowRight') move(1, 0);
              if (e.key === 'ArrowDown') move(0, 1);
              if (e.key === ' ') drop();
            };
            window.addEventListener('keydown', handleKeyDown);
            return () => window.removeEventListener('keydown', handleKeyDown);
          }, [gameState, move]);

          const startGame = () => {
            initAudio(); 
            
            const shuffled = [...WORD_PAIRS_DATA].sort(() => Math.random() - 0.5);
            setShuffledPairs(shuffled);
            
            bagRef.current = [];

            setUnlockedCount(1); 
            setLevel(1);
            setNextLevelScore(300); 
            setTimeLeft(60);        
            speedRef.current = 900;
            
            const startWords = shuffled.slice(0, 1).map(p => p[2]).join(', ');
            setTopMessage(`初始單字: ${startWords}`);

            setGrid(Array(GRID_H).fill(null).map(() => Array(GRID_W).fill(null)));
            setScore(0);
            setCombo(0);
            setClearedWords([]);
            setGameState('PLAYING');
            pendingLevelUpRef.current = false;
          };

          // 僅在第一次需要手動觸發 (在 startGame 設置狀態後，第一次 spawn 由 useEffect 觸發還是有風險)
          useEffect(() => {
             // 只有當 shuffledPairs 剛被設定，且遊戲剛開始(activePiece為空)時才觸發
             if (gameState === 'PLAYING' && activePiece === null && shuffledPairs.length > 0 && grid.every(row => row.every(c => c === null))) {
                 spawnPiece();
             }
          }, [shuffledPairs, gameState]); 

          const closeDefinitionModal = () => {
            setDefinitionModal(null);
            
            if (pendingLevelUpRef.current) {
                pendingLevelUpRef.current = false;
                setGameState('LEVEL_UP');
                setTimeLeft(prev => prev + 30);
                setLastAddedTime(30);
            } else {
                setGameState('PLAYING');
                applyGravity(grid);
            }
          };
          
          const getNewUnlockedWord = () => {
             if (unlockedCount > 0 && unlockedCount <= shuffledPairs.length) {
                 return shuffledPairs[unlockedCount - 1];
             }
             return null;
          };

          return (
            <div className="fixed inset-0 bg-slate-900 text-white font-sans flex flex-col overflow-hidden touch-none select-none">
              <audio ref={audioRef} src={BGM_URL} loop />

              {/* 頂部資訊欄 */}
              {gameState !== 'HOME' && (
                <div className="flex items-center justify-between px-4 py-2 bg-slate-800 border-b border-slate-700 h-[60px] shrink-0 z-20">
                  <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-slate-900 rounded-lg border border-slate-600 overflow-hidden p-0.5 shrink-0">
                        <img src="logo2.png" alt="Logo" className="w-full h-full object-contain" />
                    </div>
                    <div className="flex flex-col">
                      <span className="text-xs text-slate-400 font-bold">SCORE</span>
                      <span className="text-xl font-mono leading-none">{score}</span>
                    </div>
                  </div>
                  
                  <div className="flex flex-col items-center">
                     <div className="text-xs font-bold text-yellow-500">NEXT LEVEL</div>
                     <div className="text-xl font-mono leading-none flex items-center gap-1 text-white">
                       <Target size={16} /> {nextLevelScore}
                     </div>
                  </div>

                  <div className="flex gap-2">
                    <button onClick={() => setIsMuted(!isMuted)} className="p-2 bg-slate-700 rounded-full hover:bg-slate-600 active:scale-95 transition-all">
                      {isMuted ? <VolumeX size={20} className="text-red-400"/> : <Volume2 size={20} className="text-green-400"/>}
                    </button>
                    {/* Pause Button */}
                    <button 
                      onClick={() => setGameState('PAUSED')} 
                      className="p-2 bg-slate-700 rounded-full hover:bg-slate-600 active:scale-95 transition-all"
                    >
                      <PauseIcon size={20} className="text-blue-300" />
                    </button>
                    {/* Collection Button */}
                    <button 
                      onClick={() => { if (gameState === 'PLAYING') setGameState('PAUSED'); setShowCollection(true); }} 
                      className="p-2 bg-slate-700 rounded-full hover:bg-slate-600 active:scale-95 transition-all"
                    >
                      <BookOpen size={20} className="text-blue-300" />
                    </button>
                  </div>
                </div>
              )}

              {/* 遊戲主區域 */}
              <div className="flex-1 flex flex-col items-center justify-start min-h-0 w-full max-w-3xl mx-auto relative overflow-hidden">
                
                {/* 1. 上方版塊：通知 */}
                {gameState === 'PLAYING' && (
                  <div className="w-full flex justify-center py-2 px-4 shrink-0 z-10 min-h-[32px]">
                      <div className="bg-slate-800/90 border border-slate-600 rounded-full px-4 py-1 text-xs text-yellow-300 font-bold shadow-sm w-auto max-w-full text-center truncate flex items-center justify-center gap-2">
                          <Sparkles className="animate-spin-slow w-3 h-3 shrink-0 text-yellow-400" />
                          <span className="truncate">{topMessage || `Level ${level}`}</span>
                      </div>
                  </div>
                )}

                {/* 2. 遊戲網格容器 (Flex-1 to take ALL remaining space) */}
                <div 
                  className="flex-1 w-full flex items-center justify-center relative p-1"
                  onTouchStart={e => {
                      touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY, time: Date.now() };
                  }}
                  onTouchEnd={e => {
                      if (!touchStartRef.current || gameState !== 'PLAYING') return;
                      const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                      const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                      if (Math.abs(dx) > Math.abs(dy)) {
                          if (Math.abs(dx) > 30) move(dx > 0 ? 1 : -1, 0);
                      } else {
                          if (dy > 30) move(0, 1);
                          if (dy < -30) drop();
                      }
                  }}
                >
                  <div 
                    className="grid gap-[1px] bg-slate-800/50 p-1 rounded border-2 border-slate-700 shadow-xl"
                    style={{
                      aspectRatio: `${GRID_W}/${GRID_H}`,
                      height: '100%', 
                      width: 'auto',
                      maxHeight: '100%',
                      maxWidth: '100%',
                      objectFit: 'contain',
                      gridTemplateColumns: `repeat(${GRID_W}, minmax(0, 1fr))`
                    }}
                  >
                    {grid.map((row, y) => (
                      row.map((cell, x) => {
                        let activeCell = null;
                        if (activePiece) {
                          const sy = y - activePiece.y;
                          const sx = x - activePiece.x;
                          if (sy >= 0 && sy < activePiece.shape.length && sx >= 0 && sx < activePiece.shape[0].length) {
                            activeCell = activePiece.shape[sy][sx];
                          }
                        }

                        const renderData = activeCell || cell;
                        const isGhost = renderData && renderData.type === 'ghost';
                        
                        return (
                          <div 
                            key={`${x}-${y}`} 
                            className={`
                              w-full h-full rounded-[1px] md:rounded-[2px] flex items-center justify-center font-bold overflow-hidden transition-colors duration-75
                              ${renderData ? renderData.color : 'bg-slate-800/30'}
                              ${isGhost ? 'opacity-40' : ''}
                              ${activeCell && !isGhost ? 'ring-1 ring-white/80 z-10' : ''}
                              text-xs md:text-base lg:text-xl
                            `}
                          >
                             {/* Responsive text size */}
                             <span className="text-[10px] xs:text-xs sm:text-sm md:text-base select-none leading-none">
                               {renderData && !isGhost ? renderData.text : ''}
                             </span>
                          </div>
                        );
                      })
                    ))}
                  </div>

                  {/* 消除特效 */}
                  {clearedWords.length > 0 && !definitionModal && gameState !== 'LEVEL_UP' && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/40 backdrop-blur-sm z-30 animate-fade-out pointer-events-none">
                      <Sparkles className="text-yellow-400 w-16 h-16 mb-4 animate-bounce" />
                      {clearedWords.map((word, i) => (
                        <div key={i} className="text-4xl font-bold text-yellow-300 drop-shadow-[0_4px_4px_rgba(0,0,0,0.8)] animate-pulse mb-2">
                          {word.toUpperCase()}
                        </div>
                      ))}
                      <div className="text-2xl text-green-400 mt-2 font-mono">+{100 * (combo)} pts</div>
                      <div className="text-xl text-yellow-400 mt-1 font-mono">+{lastAddedTime} sec</div>
                    </div>
                  )}
                </div>
              </div>

              {/* 3. 下方控制區 (Fixed height at bottom) */}
              <div className="w-full px-4 pb-4 pt-2 shrink-0 bg-slate-900 z-20">
                  <div className="grid grid-cols-3 gap-2 h-10 w-full max-w-sm mx-auto">
                    {/* 左 */}
                    <button 
                      className="bg-slate-800 rounded-lg flex items-center justify-center active:bg-slate-700 active:scale-95 transition-all border border-slate-600 shadow-md btn-active touch-manipulation"
                      onMouseDown={(e) => { e.preventDefault(); move(-1, 0); }}
                      onTouchStart={(e) => { e.preventDefault(); move(-1, 0); }}
                    >
                      <ArrowLeft size={18} className="text-slate-300" />
                    </button>
                    
                    {/* 下 (加速) */}
                    <button 
                      className="bg-slate-800 rounded-lg flex items-center justify-center active:bg-slate-700 active:scale-95 transition-all border border-slate-600 shadow-md btn-active touch-manipulation"
                      onMouseDown={(e) => { e.preventDefault(); move(0, 1); }}
                      onTouchStart={(e) => { e.preventDefault(); move(0, 1); }}
                    >
                      <ArrowDown size={18} className="text-slate-300" />
                    </button>

                    {/* 右 */}
                    <button 
                      className="bg-slate-800 rounded-lg flex items-center justify-center active:bg-slate-700 active:scale-95 transition-all border border-slate-600 shadow-md btn-active touch-manipulation"
                      onMouseDown={(e) => { e.preventDefault(); move(1, 0); }}
                      onTouchStart={(e) => { e.preventDefault(); move(1, 0); }}
                    >
                      <ArrowRight size={18} className="text-slate-300" />
                    </button>
                </div>
              </div>

              {/* 暫停選單 */}
              {gameState === 'PAUSED' && !definitionModal && (
                <div className="absolute inset-0 z-50 bg-slate-900/95 flex flex-col items-center justify-center p-6 text-center animate-in fade-in zoom-in duration-200">
                   <div className="bg-slate-800 p-8 rounded-2xl border border-slate-600 shadow-2xl max-w-sm w-full space-y-4">
                     <h2 className="text-3xl font-bold text-white mb-2 tracking-wider">PAUSED</h2>
                     
                     <button onClick={() => setGameState('PLAYING')} className="w-full py-4 bg-blue-600 hover:bg-blue-500 rounded-xl font-bold text-xl text-white shadow-lg">
                       Resume
                     </button>
                     
                     <button onClick={() => setShowCollection(true)} className="w-full py-3 bg-slate-700 hover:bg-slate-600 rounded-xl font-bold text-lg text-slate-200 border border-slate-600">
                       <BookOpen size={18} className="inline mr-2" /> Word Collection
                     </button>
                     
                     <button onClick={() => setGameState('HOME')} className="w-full py-3 bg-red-900/50 hover:bg-red-900/70 rounded-xl font-bold text-lg text-red-300 border border-red-800/50">
                       Exit to Home
                     </button>
                   </div>
                </div>
              )}

              {/* 升級畫面 */}
              {gameState === 'LEVEL_UP' && (
                <div className="absolute inset-0 z-50 bg-slate-900/95 flex flex-col items-center justify-center p-6 text-center animate-in fade-in zoom-in duration-300">
                   <div className="bg-slate-800 p-8 rounded-2xl border-2 border-yellow-500 shadow-[0_0_50px_rgba(234,179,8,0.3)] max-w-sm w-full">
                     <Trophy className="w-20 h-20 text-yellow-400 mb-6 mx-auto animate-bounce" />
                     <h2 className="text-4xl font-black text-white mb-2 tracking-wider">LEVEL {level}</h2>
                     <p className="text-slate-400 text-sm mb-6 uppercase tracking-widest">Completed!</p>
                     
                     {getNewUnlockedWord() ? (
                        <div className="bg-slate-900/50 p-4 rounded-xl border border-slate-700 mb-8">
                            <div className="text-xs text-green-400 font-bold mb-2 uppercase">New Word Unlocked</div>
                            <div className="text-3xl font-bold text-white mb-1">{getNewUnlockedWord()[2]}</div>
                            <div className="text-sm text-slate-300">{getNewUnlockedWord()[4]}</div>
                        </div>
                     ) : (
                        <div className="mb-8 text-slate-300">Keep going!</div>
                     )}

                     <button onClick={continueLevel} className="w-full py-4 bg-gradient-to-r from-yellow-500 to-orange-500 rounded-xl font-bold text-xl shadow-lg shadow-orange-900/40 active:scale-95 transition-transform text-white">
                       Start Level {level}
                     </button>
                   </div>
                </div>
              )}

              {/* 首頁 */}
              {gameState === 'HOME' && (
                <div className="absolute inset-0 z-50 bg-slate-900 flex flex-col items-center justify-center p-4 text-center space-y-4">
                   <div className="w-24 h-24 bg-slate-800 rounded-2xl flex items-center justify-center border-4 border-slate-700 shadow-2xl rotate-3 overflow-hidden shrink-0">
                      <img src="logo.png" alt="Logo" className="w-full h-full object-contain" />
                   </div>

                   <div className="shrink-0">
                     <h1 className="text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-green-400 mb-1">
                       Word Tetris
                     </h1>
                     <p className="text-slate-400 text-xs">Vocabulary Puzzle Game</p>
                   </div>

                   <div className="bg-slate-800/90 p-5 rounded-xl border border-slate-700 max-w-sm w-full backdrop-blur-sm overflow-y-auto custom-scrollbar flex-1 min-h-0 flex flex-col">
                     
                     {/* 詞綴解釋區塊 */}
                     <div className="mb-4 bg-slate-900/60 p-3 rounded-lg text-left border border-slate-700 shrink-0">
                        <h3 className="text-yellow-400 font-bold mb-2 text-sm flex items-center gap-2 border-b border-slate-700/50 pb-1">
                          <BookOpen size={16}/> 什麼是詞綴 (Affixes)?
                        </h3>
                        <div className="text-xs text-slate-300 space-y-3">
                          <div>
                            <div className="flex items-center gap-2 mb-1">
                                <span className="bg-blue-600 text-white px-1.5 py-0.5 rounded text-[10px] font-bold">Prefix 前綴</span>
                                <span className="text-slate-400">放在單字開頭</span>
                            </div>
                            <div className="pl-2 border-l-2 border-blue-500/30 text-slate-400">
                              改變意思。例: <span className="text-blue-400 font-bold">un</span>(不) + happy = <span className="text-white">unhappy</span>
                            </div>
                          </div>
                          <div>
                            <div className="flex items-center gap-2 mb-1">
                                <span className="bg-orange-500 text-white px-1.5 py-0.5 rounded text-[10px] font-bold">Suffix 後綴</span>
                                <span className="text-slate-400">放在單字結尾</span>
                            </div>
                            <div className="pl-2 border-l-2 border-orange-500/30 text-slate-400">
                              改變詞性。例: teach + <span className="text-orange-400 font-bold">er</span>(人) = <span className="text-white">teacher</span>
                            </div>
                          </div>
                        </div>
                     </div>

                     <div className="border-t border-slate-700/50 my-2"></div>

                     <h2 className="text-lg font-bold text-white mb-2 flex items-center gap-2 shrink-0">
                       <Target className="text-red-400" size={18}/> 遊戲規則
                     </h2>
                     <ul className="text-left text-xs text-slate-300 space-y-2 mb-6 flex-1">
                       <li className="flex gap-2"><span className="text-blue-400">●</span> <b>學習目標</b>: 熟悉英語詞綴組合 (Prefix/Suffix)。</li>
                       <li className="flex gap-2"><span className="text-yellow-400">●</span> <b>如何操作</b>: 電腦用方向鍵/空白鍵，手機滑動控制。</li>
                       <li className="flex gap-2"><span className="text-slate-500">●</span> <b>遊戲目標</b>: 盡量取得高分！每 500 分解鎖新詞。</li>
                       <li className="flex gap-2"><span className="text-green-400">●</span> <b>查看提示</b>: 點擊右上角書本圖示 <BookOpen size={12} className="inline"/>。</li>
                     </ul>
                     
                     <button onClick={startGame} className="w-full py-3 bg-gradient-to-r from-green-600 to-emerald-600 rounded-xl font-bold text-lg shadow-lg shadow-green-900/40 active:scale-95 transition-transform flex items-center justify-center gap-2 shrink-0">
                       <Play fill="currentColor" size={20} /> 開始遊戲
                     </button>
                   </div>
                </div>
              )}

              {/* 彈窗 */}
              {definitionModal && (
                <div className="absolute inset-0 z-50 bg-slate-900/95 flex flex-col items-center justify-center p-6 text-center animate-in fade-in zoom-in duration-200">
                   <div className="bg-slate-800 p-8 rounded-2xl border border-slate-600 shadow-2xl max-w-sm w-full">
                     <BookOpen className="w-16 h-16 text-blue-400 mb-4 mx-auto animate-bounce" />
                     <div className="text-sm text-yellow-500 font-bold tracking-widest uppercase mb-2">New Discovery</div>
                     <div className="text-4xl font-bold text-white mb-4">{definitionModal.full}</div>
                     <div className="space-y-4 mb-8">
                       <div className="bg-slate-900/50 p-3 rounded-lg">
                         <div className="text-2xl text-green-400 font-bold">{definitionModal.meaning_zh}</div>
                       </div>
                       <div className="bg-slate-900/50 p-3 rounded-lg">
                         <div className="text-sm text-slate-300 italic">"{definitionModal.meaning_en}"</div>
                       </div>
                     </div>
                     <button onClick={closeDefinitionModal} className="w-full py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-bold shadow-lg shadow-blue-900/30">
                       Continue
                     </button>
                   </div>
                </div>
              )}

              {/* 收藏庫 */}
              {showCollection && (
                <div className="absolute inset-0 z-50 bg-slate-900/95 flex flex-col p-4 animate-in slide-in-from-bottom duration-200">
                  <div className="flex justify-between items-center mb-4 shrink-0">
                    <h2 className="text-2xl font-bold text-white flex items-center gap-2"><BookOpen /> Collection</h2>
                    <button onClick={() => { setShowCollection(false); if(gameState === 'PAUSED') setGameState('PLAYING'); }} className="p-2 bg-slate-800 rounded-full"><X /></button>
                  </div>
                  <div className="text-sm text-slate-400 mb-2 px-2">Current Session Unlocks ({Math.min(unlockedCount, shuffledPairs.length)}/{shuffledPairs.length})</div>
                  <div className="flex-1 overflow-y-auto space-y-2 pr-2 custom-scrollbar">
                    {/* 只顯示目前這局已解鎖 (在 shuffledPairs 範圍內) 的單字 */}
                    {shuffledPairs.slice(0, unlockedCount).map(([p1, p2, full, reqLevel, zh, en], idx) => {
                      const isDiscovered = discoveredWords.has(full);
                      return (
                        <div key={idx} className={`p-3 rounded-lg border ${isDiscovered ? 'bg-slate-800 border-green-500/50' : 'bg-slate-800/50 border-slate-700'}`}>
                          <div className="flex justify-between items-center mb-1">
                            <div className="flex items-center gap-1 font-mono text-sm">
                              <span className="text-blue-400">{p1}</span>+<span className="text-orange-400">{p2}</span>
                            </div>
                            {isDiscovered ? (
                               <span className="text-green-400 font-bold">{full}</span>
                            ) : (
                               <span className="text-slate-600 font-bold">???</span>
                            )}
                          </div>
                          {isDiscovered && (
                            <div className="text-xs text-slate-400 border-t border-slate-700/50 pt-2 mt-2">
                               <span className="text-white mr-2">{zh}</span>
                               <span className="italic text-slate-500">{en}</span>
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                  {gameState === 'PAUSED' && (
                    <div className="mt-4 pt-4 border-t border-slate-700 shrink-0">
                       <button onClick={() => { setGameState('HOME'); setShowCollection(false); }} className="w-full py-3 bg-red-600/20 text-red-400 rounded-xl font-bold border border-red-600/50 mb-2">Quit Game</button>
                       <button onClick={() => { setShowCollection(false); setGameState('PLAYING'); }} className="w-full py-3 bg-blue-600 text-white rounded-xl font-bold">Resume</button>
                    </div>
                  )}
                </div>
              )}

              {/* 結束畫面 */}
              {gameState === 'GAMEOVER' && (
                <div className="absolute inset-0 z-50 bg-slate-900/90 flex flex-col items-center justify-center p-6 text-center animate-in fade-in duration-300">
                   <h2 className="text-5xl font-bold text-slate-200 mb-2">GAME OVER</h2>
                   <div className="text-lg text-yellow-400 mb-8 font-bold">
                     {score > 2000 ? "太厲害了！" : score > 1000 ? "不錯喔！" : "繼續加油！"}
                   </div>
                   
                   <div className="bg-slate-800 p-6 rounded-2xl border border-slate-700 w-full max-w-xs mb-8">
                     <div className="text-slate-400 text-sm uppercase tracking-wider mb-1">Final Score</div>
                     <div className="text-4xl font-mono text-white mb-4">{score}</div>
                     <div className="flex justify-between text-sm border-t border-slate-700 pt-4">
                       <div className="text-slate-400">Words Found</div>
                       <div className="text-green-400">{discoveredWords.size}</div>
                     </div>
                   </div>

                   <button onClick={startGame} className="px-8 py-4 bg-blue-600 hover:bg-blue-500 rounded-xl font-bold text-xl w-full max-w-xs flex items-center justify-center gap-2 shadow-lg shadow-blue-900/40 active:scale-95 transition-transform">
                     <RotateCcw /> Play Again
                   </button>
                   <button onClick={() => setGameState('HOME')} className="mt-4 text-slate-500 text-sm hover:text-white">Back to Home</button>
                </div>
              )}
            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<WordTetris />);
    </script>
</body>
</html>
